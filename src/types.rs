use std::sync::Arc;

use ark_poly::univariate::DensePolynomial;
use ark_serialize::{
    CanonicalDeserialize, CanonicalSerialize, CompressedChecked, SerializationError,
};

use crate::kzg::UniversalParams;
use crate::snark::{AggregationKey, Curve, PartyError, Proof, VerifierKey, F, G1, G2};

use serde::{Deserialize, Serialize};

/// Global data for a hints setup.
///
/// Contains the KZG parameters and the cache of precomputed Lagrange polynomials and commitments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Serialize)]
pub struct GlobalData {
    #[serde_as(as = "CompressedChecked<UniversalParams<Curve>>")]
    pub params: UniversalParams<Curve>,
    /// Used for domain separation in lockstitch
    pub domain: String,
    #[serde_as(as = "Vec<CompressedChecked<DensePolynomial<F>>>")]
    pub(crate) lagrange_polynomials: Vec<DensePolynomial<F>>,
    #[serde_as(as = "Vec<CompressedChecked<G1>>")]
    pub(crate) lagrange_coms_g1: Vec<G1>,
    #[serde_as(as = "Vec<CompressedChecked<G2>>")]
    pub(crate) lagrange_coms_g2: Vec<G2>,
    #[serde(skip)]
    pub(crate) lockstitch: lockstitch::Protocol,
}

impl<'de> Deserialize<'de> for GlobalData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(Deserialize)]
        // keeping the same name makes the generated code more consistent
        struct GlobalData {
            #[serde_as(as = "CompressedChecked<UniversalParams<Curve>>")]
            pub params: UniversalParams<Curve>,
            /// Used for domain separation in lockstitch
            pub domain: String,
            #[serde(with = "ark_serialize::serde::vec_compressed_checked")]
            pub(crate) lagrange_polynomials: Vec<DensePolynomial<F>>,
            #[serde(with = "ark_serialize::serde::vec_compressed_checked")]
            pub(crate) lagrange_coms_g1: Vec<G1>,
            #[serde(with = "ark_serialize::serde::vec_compressed_checked")]
            pub(crate) lagrange_coms_g2: Vec<G2>,
        }
        let inner = GlobalData::deserialize(deserializer)?;
        let lockstitch = lockstitch::Protocol::new(&inner.domain);
        Ok(crate::GlobalData {
            params: inner.params,
            domain: inner.domain,
            lagrange_polynomials: inner.lagrange_polynomials,
            lagrange_coms_g1: inner.lagrange_coms_g1,
            lagrange_coms_g2: inner.lagrange_coms_g2,
            lockstitch,
        })
    }
}

/// Setup for a universe of participants
///
/// Includes all relevant parameters and data for a given setup,
/// and any errors that occurred aggregating hints.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UniverseSetup {
    pub agg_key: Arc<CompressedChecked<AggregationKey>>,
    pub vk: Arc<CompressedChecked<VerifierKey>>,
    pub global: Arc<GlobalData>,
    pub party_errors: Vec<(usize, PartyError)>,
}

/// Aggregates partial signatures and generates a final signature with proof.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Aggregator {
    pub global: Arc<GlobalData>,
    pub agg_key: Arc<CompressedChecked<AggregationKey>>,
}

/// Verifies signatures and proofs.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Verifier {
    pub global: Arc<GlobalData>,
    pub vk: Arc<CompressedChecked<VerifierKey>>,
}

impl UniverseSetup {
    pub fn aggregator(&self) -> Aggregator {
        Aggregator {
            global: self.global.clone(),
            agg_key: self.agg_key.clone(),
        }
    }

    pub fn verifier(&self) -> Verifier {
        Verifier {
            global: self.global.clone(),
            vk: self.vk.clone(),
        }
    }
}

/// Hint generated by a party, containing commitments related to their secret key.
#[derive(
    Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize, Serialize, Deserialize,
)]
#[serde(from = "CompressedChecked<Self>", into = "CompressedChecked<Self>")]
pub struct Hint {
    /// Commitment [sk_i * L_i(τ)]_2.
    pub com_sk_li_tau: G2,
    /// Commitments [sk_i * F_ij]_1 for sumcheck Qz (n elements).
    pub com_q1_contributions: Vec<G1>,
    /// Commitment [sk_i * F'_i]_1 for sumcheck Qx.
    pub com_q2_contribution: G1,
}

/// Hints Errors.
#[derive(Debug)]
pub enum HintsError {
    KzgSetupError(crate::kzg::Error),
    PolynomialDegreeTooLarge,
    ProofVerificationError(String),
    HintVerificationError(String),
    VerificationStep(&'static str),
    TrustedSetupError(crate::trusted_setup::TrustedSetupError),
    InvalidInput(String),
    ThresholdNotMet,
    BlsVerificationFailed,
    SerializationError(SerializationError),
    #[cfg(feature = "parallel")]
    RayonJoinError,
}

impl From<crate::kzg::Error> for HintsError {
    fn from(e: crate::kzg::Error) -> Self {
        HintsError::KzgSetupError(e)
    }
}

impl From<SerializationError> for HintsError {
    fn from(e: SerializationError) -> Self {
        HintsError::SerializationError(e)
    }
}

impl std::fmt::Display for HintsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HintsError::KzgSetupError(e) => write!(f, "KZG Setup Error: {:?}", e),
            HintsError::PolynomialDegreeTooLarge => {
                write!(f, "Polynomial degree too large for CRS")
            }
            HintsError::ProofVerificationError(s) => write!(f, "Proof verification failed: {}", s),
            HintsError::HintVerificationError(s) => write!(f, "Hint verification failed: {}", s),
            HintsError::VerificationStep(s) => write!(f, "failing step: {}", s),
            HintsError::TrustedSetupError(e) => write!(f, "Trusted setup error: {:?}", e),
            HintsError::InvalidInput(s) => write!(f, "Invalid input: {}", s),
            HintsError::ThresholdNotMet => write!(f, "Aggregated weight does not meet threshold"),
            HintsError::BlsVerificationFailed => {
                write!(f, "Aggregated BLS signature verification failed")
            }
            HintsError::SerializationError(e) => write!(f, "Serialization error: {}", e),
            #[cfg(feature = "parallel")]
            HintsError::RayonJoinError => write!(f, "Parallel computation join error"),
        }
    }
}

impl From<crate::trusted_setup::TrustedSetupError> for HintsError {
    fn from(e: crate::trusted_setup::TrustedSetupError) -> Self {
        HintsError::TrustedSetupError(e)
    }
}

impl std::error::Error for HintsError {}

/// BLS Secret Key.
#[derive(
    Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize, Serialize, Deserialize,
)]
#[serde(from = "CompressedChecked<Self>", into = "CompressedChecked<Self>")]
pub struct SecretKey(pub F);

/// BLS Public Key.
#[derive(
    Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize, Serialize, Deserialize,
)]
#[serde(from = "CompressedChecked<Self>", into = "CompressedChecked<Self>")]
pub struct PublicKey(pub G1);

/// BLS Partial Signature.
#[derive(
    Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize, Serialize, Deserialize,
)]
#[serde(from = "CompressedChecked<Self>", into = "CompressedChecked<Self>")]
pub struct PartialSignature(pub G2);

/// Final Aggregated Signature.
#[derive(
    Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize, Serialize, Deserialize,
)]
#[serde(from = "CompressedChecked<Self>", into = "CompressedChecked<Self>")]
pub struct Signature {
    /// Aggregated BLS signature σ' = H(m)^aSK.
    pub agg_sig_prime: G2,
    /// The threshold for the signature.
    pub threshold: F,
    /// The SNARK proof π.
    pub proof: Proof,
}

macro_rules! froms {
    ($($t:ty),*) => {
        $(
            impl From<CompressedChecked<$t>> for $t {
                fn from(sig: CompressedChecked<$t>) -> Self {
                    sig.0
                }
            }
        )*
    };
}

froms!(SecretKey, PublicKey, PartialSignature, Signature, Hint);
