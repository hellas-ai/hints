use std::sync::Arc;

use ark_poly::univariate::DensePolynomial;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, SerializationError};

use crate::kzg::UniversalParams;
use crate::snark::{AggregationKey, Curve, PartyError, Proof, VerifierKey, F, G1, G2};

/// Global data for a hints setup.
///
/// Contains the KZG parameters and the cache of precomputed Lagrange polynomials and commitments.
#[derive(Clone, Debug)]
pub struct GlobalData {
    pub params: UniversalParams<Curve>,
    pub domain_max: usize,
    pub(crate) lagrange_polynomials: Vec<DensePolynomial<F>>,
    pub(crate) lagrange_coms_g1: Vec<G1>,
    pub(crate) lagrange_coms_g2: Vec<G2>,
    pub(crate) lockstitch: lockstitch::Protocol,
}

/// Setup for a universe of participants
/// 
/// Includes all relevant parameters and data for a given setup,
/// and any errors that occurred aggregating hints.
pub struct UniverseSetup {
    pub agg_key: Arc<AggregationKey>,
    pub vk: Arc<VerifierKey>,
    pub global: Arc<GlobalData>,
    pub party_errors: Vec<(usize, PartyError)>,
}

/// Aggregates partial signatures and generates a final signature with proof.
pub struct Aggregator {
    pub global: Arc<GlobalData>,
    pub agg_key: Arc<AggregationKey>,
}

/// Verifies signatures and proofs.
pub struct Verifier {
    pub global: Arc<GlobalData>,
    pub vk: Arc<VerifierKey>,
}

impl UniverseSetup {
    pub fn aggregator(&self) -> Aggregator {
        Aggregator {
            global: self.global.clone(),
            agg_key: self.agg_key.clone(),
        }
    }

    pub fn verifier(&self) -> Verifier {
        Verifier {
            global: self.global.clone(),
            vk: self.vk.clone(),
        }
    }
}

/// Hint generated by a party, containing commitments related to their secret key.
#[derive(Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct Hint {
    /// Commitment [sk_i * L_i(τ)]_2.
    pub com_sk_li_tau: G2,
    /// Commitments [sk_i * F_ij]_1 for sumcheck Qz (n elements).
    pub com_q1_contributions: Vec<G1>,
    /// Commitment [sk_i * F'_i]_1 for sumcheck Qx.
    pub com_q2_contribution: G1,
}

/// Hints Errors.
#[derive(Debug)]
pub enum HintsError {
    KzgSetupError(crate::kzg::Error),
    PolynomialDegreeTooLarge,
    ProofVerificationError(String),
    HintVerificationError(String),
    VerificationStep(&'static str),
    TrustedSetupError(crate::trusted_setup::TrustedSetupError),
    InvalidInput(String),
    ThresholdNotMet,
    BlsVerificationFailed,
    SerializationError(SerializationError),
    #[cfg(feature = "parallel")]
    RayonJoinError,
}

impl From<crate::kzg::Error> for HintsError {
    fn from(e: crate::kzg::Error) -> Self {
        HintsError::KzgSetupError(e)
    }
}

impl From<SerializationError> for HintsError {
    fn from(e: SerializationError) -> Self {
        HintsError::SerializationError(e)
    }
}

impl std::fmt::Display for HintsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HintsError::KzgSetupError(e) => write!(f, "KZG Setup Error: {:?}", e),
            HintsError::PolynomialDegreeTooLarge => {
                write!(f, "Polynomial degree too large for CRS")
            }
            HintsError::ProofVerificationError(s) => write!(f, "Proof verification failed: {}", s),
            HintsError::HintVerificationError(s) => write!(f, "Hint verification failed: {}", s),
            HintsError::VerificationStep(s) => write!(f, "failing step: {}", s),
            HintsError::TrustedSetupError(e) => write!(f, "Trusted setup error: {:?}", e),
            HintsError::InvalidInput(s) => write!(f, "Invalid input: {}", s),
            HintsError::ThresholdNotMet => write!(f, "Aggregated weight does not meet threshold"),
            HintsError::BlsVerificationFailed => {
                write!(f, "Aggregated BLS signature verification failed")
            }
            HintsError::SerializationError(e) => write!(f, "Serialization error: {}", e),
            #[cfg(feature = "parallel")]
            HintsError::RayonJoinError => write!(f, "Parallel computation join error"),
        }
    }
}

impl From<crate::trusted_setup::TrustedSetupError> for HintsError {
    fn from(e: crate::trusted_setup::TrustedSetupError) -> Self {
        HintsError::TrustedSetupError(e)
    }
}

impl std::error::Error for HintsError {}

/// BLS Secret Key.
#[derive(
    Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, CanonicalSerialize, CanonicalDeserialize,
)]
pub struct SecretKey(pub F);

/// BLS Public Key.
#[derive(Copy, Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct PublicKey(pub G1);

/// BLS Partial Signature.
#[derive(Copy, Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct PartialSignature(pub G2);

/// Final Aggregated Signature.
#[derive(Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct Signature {
    /// Aggregated BLS signature σ' = H(m)^aSK.
    pub agg_sig_prime: G2,
    /// The threshold for the signature.
    pub threshold: F,
    /// The SNARK proof π.
    pub proof: Proof,
}
